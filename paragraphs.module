<?php
/**
 * @file
 * Paragraphs hooks and common functions.
 * Paragraphs allows you to embed multiple entity types in field.
 */

define('PARAGRAPHS_RECURSION_LIMIT', 20);
define('PARAGRAPHS_DEFAULT_TITLE', 'Paragraph');
define('PARAGRAPHS_DEFAULT_TITLE_MULTIPLE', 'Paragraphs');
define('PARAGRAPHS_DEFAULT_EDIT_MODE', 'open');
define('PARAGRAPHS_DEFAULT_EDIT_MODE_OVERRIDE', 1);
define('PARAGRAPHS_DEFAULT_ADD_MODE', 'select');

/**
 * Modules should return this value from hook_paragraphs_item_access() to allow access to a paragraphs item.
 */
define('PARAGRAPHS_ITEM_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_paragraphs_item_access() to deny access to a paragraphs item.
 */
define('PARAGRAPHS_ITEM_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_paragraphs_item_access() to not affect paragraphs item access.
 */
define('PARAGRAPHS_ITEM_ACCESS_IGNORE', NULL);


// Separate some Field API parts in different files.
require_once dirname(__FILE__) . '/paragraphs.field_formatter.inc';
require_once dirname(__FILE__) . '/paragraphs.field_widget.inc';
require_once dirname(__FILE__) . '/paragraphs.node_clone.inc';

/**
 * Loads a paragraphs item.
 *
 * @param $item_id
 *   The paragraphs item ID.
 * @param $reset
 *   Should we reset the entity cache?
 * @return ParagraphsItemEntity
 *   The paragraphs item entity or FALSE.
 */
function paragraphs_item_load($item_id, $reset = FALSE) {
  $result = paragraphs_item_load_multiple(array($item_id), array(), $reset);
  return $result ? reset($result) : FALSE;
}

/**
 * Loads a paragraphs revision.
 *
 * @param $revision_id
 *   The paragraphs revision ID.
 * @return ParagraphsItemEntity
 *   The paragraphs item entity or FALSE.
 */
function paragraphs_item_revision_load($revision_id) {
  //Note: [Temporarily?] duplicating entity_revision_load functionality. If this
  //gets into core (https://github.com/backdrop/backdrop-issues/issues/3777)
  //or we make a dependency on Entity Plus we could revert.
  $info = entity_get_info('paragraphs_item');
  if (!empty($info['entity keys']['revision'])) {
    $entity_revisions = entity_load('paragraphs_item', FALSE, array($info['entity keys']['revision'] => $revision_id));
    return reset($entity_revisions);
  }
  return FALSE;
}

/**
 * Loads paragraphs items.
 *
 * @param $ids
 *   An array of paragraphs item IDs or FALSE to load all.
 * @param $conditions
 *   Should we reset the entity cache?
 * @param $reset
 *   Should we reset the entity cache?
 * @return ParagraphsItemEntity[]
 *   An array of paragraphs item entities.
 */
function paragraphs_item_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load_multiple('paragraphs_item', $ids, $conditions, $reset);
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function paragraphs_ctools_plugin_directory($module, $plugin) {
  if ($module == 'panelizer' && $plugin == 'entity') {
    return 'plugins/panelizer/entity';
  }
}

/**
 * Implements hook_entity_info().
 */
function paragraphs_entity_info() {
  $return['paragraphs_item'] = array(
    'label' => t('Paragraphs item'),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'entity class' => 'ParagraphsItemEntity',
    'controller class' => 'ParagraphsItemController',
    'base table' => 'paragraphs_item',
    'revision table' => 'paragraphs_item_revision',
    'fieldable' => TRUE,
    // For integration with Redirect module.
    // @see http://drupal.org/node/1263884
    'redirect' => FALSE,
    'entity keys' => array(
      'id' => 'item_id',
      'revision' => 'revision_id',
      // TODO: deprecate warning on 'bundle'?
      'bundle' => 'bundle',
      'type' => 'type',
      'field_name' => 'field_name',
    ),
    'module' => 'paragraphs',
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
      'paragraphs_editor_preview' => array(
        'label' => t('Paragraphs Editor Preview'),
        'custom settings' => TRUE,
      ),
    ),
    // TODO: deprecate warning on 'bundle'?
    'bundle keys' => array(
      'bundle' => 'bundle',
    ),
    'type keys' => array(
      'type' => 'type',
    ),
    'access callback' => 'paragraphs_item_access',
  );

  $types = paragraphs_type_load();

  // Add info about the types. We do not use field_info_fields() but directly
  // use field_read_fields() as field_info_fields() requires built entity info
  // to work.
  foreach ($types as $machine_name => $type) {
    // TODO: adjust 'bundle' to 'type' after schema is updated
    $return['paragraphs_item']['bundles'][$type->bundle] = array(
      'label' => $type->name,
      'admin' => array(
        'path' => 'admin/structure/paragraphs/%paragraphs_type',
        'real path' => 'admin/structure/paragraphs/' . strtr($machine_name, array('_' => '-')),
        'type argument' => 3,
        'access arguments' => array('administer paragraphs types'),
      ),
    );
  }

  if (module_exists('entitycache')) {
    $return['paragraphs_item']['field cache'] = FALSE;
    $return['paragraphs_item']['entity cache'] = TRUE;
  }

  return $return;
}

/**
 * Access check for paragraphs.
 *
 * Most of the time the access callback is on the host entity.
 * In some cases you want specific access checks on paragraphs.
 * You can do this by implementing hook_paragraphs_item_access().
 *
 * @return bool
 *   Whether the user has access to a paragraphs item.
 */
function paragraphs_item_access($op, $entity, $account, $entity_type) {
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }
  $permissions = &backdrop_static(__FUNCTION__, array());

  // If the $op was not one of the supported ones, we return access denied.
  if (!in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    return FALSE;
  }

  // When we have no entity, create a generic cid.
  if (empty($entity)) {
    $cid = 'all_entities:' . $op;
  }
  // When OP is create, or the entity is new, the type is the cache key.
  elseif ($op == 'create' || (isset($entity->is_new) && $entity->is_new)) {
    $cid = $entity->bundle;
  }
  // Else our cid is entity specific.
  else {
    $cid = $entity->item_id . '_' . $entity->revision_id;
  }

  // If we've already checked access for this type, user and op, return from
  // cache. Otherwise, we are optimistic and consider that the user can
  // view / update / delete or create a paragraph.
  if (isset($permissions[$account->uid][$cid][$op])) {
    return $permissions[$account->uid][$cid][$op];
  }

  // We grant access to the paragraph item if both of the following conditions are met:
  // - No modules say to deny access.
  // - At least one module says to grant access.
  // If no module specified either allow or deny, we always allow.
  $access = module_invoke_all('paragraphs_item_access', $entity, $op, $account);
  if (in_array(PARAGRAPHS_ITEM_ACCESS_DENY, $access, TRUE)) {
    $user_access_permission = FALSE;
  }
  elseif (in_array(PARAGRAPHS_ITEM_ACCESS_ALLOW, $access, TRUE)) {
    $user_access_permission = TRUE;
  }
  else {
    // Deny access by default.
    $user_access_permission = FALSE;
  }

  // Store the result of the permission in our matrix.
  $permissions[$account->uid][$cid][$op] = $user_access_permission;

  return $permissions[$account->uid][$cid][$op];
}

/**
 * Access check for paragraphs.
 *
 * Finds the parent entity and then checks for access on the parent entity.
 *
 * @param ParagraphsItemEntity $entity
 *   The entity to check for.
 *
 * @param string $op
 *   The operation to check for.
 *
 * @param $account
 *   The account to check for.
 *
 * @return bool
 *   Whether the user has access to a paragraphs item.
 */
function paragraphs_paragraphs_item_access($entity, $op, $account) {
  $permissions = &backdrop_static(__FUNCTION__, array());
  $parent_permissions = &backdrop_static(__FUNCTION__  . '_parents', array());

  if (!in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    // If there was no type to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return PARAGRAPHS_ITEM_ACCESS_IGNORE;
  }

  $check_parent_op = $op;

  // Update/Delete/Create access requires update access on the parent.
  if (in_array($op, array('update', 'delete', 'create'), TRUE)) {
    $check_parent_op = 'update';
  }

  // When we have no entity, create a generic cid.
  if (empty($entity)) {
    $cid = 'all_entities:' . $op;
  }
  // When OP is create, or the entity is new, the type is the cache key.
  elseif ($op == 'create' || (isset($entity->is_new) && $entity->is_new)) {
    $cid = $entity->bundle;
  }
  // Else our cid is entity specific.
  else {
    $cid = $entity->item_id . '_' . $entity->revision_id;
  }

  // Check if we cached permission check.
  if (isset($permissions[$account->uid][$cid][$op])) {
    return $permissions[$account->uid][$cid][$op];
  }

  if (empty($entity)) {
    // Ignore access when we don't have a host entity.
    $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_IGNORE;
  }
  elseif ($host_entity = $entity->hostEntity()) {
    $host_entity_info = entity_get_info($entity->hostEntityType());
    $host_id_key = $host_entity_info['entity keys']['id'];

    $parent_cid = $entity->hostEntityType() . '_' . implode('_', entity_extract_ids($entity->hostEntityType(), $host_entity));

    // Check if we have an ID key set, if not parent entity is new, we check for create access.
    if (!isset($host_entity->{$host_id_key}) || empty($host_entity->{$host_id_key})) {
      $check_parent_op = 'create';
      $host_entity->is_new = TRUE;
    }

    if (isset($parent_permissions[$account->uid][$parent_cid][$check_parent_op])) {
      return $parent_permissions[$account->uid][$parent_cid][$check_parent_op];
    }

    if (paragraphs_entity_access($check_parent_op, $entity->hostEntityType(), $host_entity)) {
      $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_ALLOW;
      $parent_permissions[$account->uid][$parent_cid][$check_parent_op] = PARAGRAPHS_ITEM_ACCESS_ALLOW;
    }
    else {
      // Deny access as parent entity access failed.
      $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_DENY;
      $parent_permissions[$account->uid][$parent_cid][$check_parent_op] = PARAGRAPHS_ITEM_ACCESS_DENY;
    }
  }
  else {
    // Ignore access when we don't have a host entity.
    $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_IGNORE;
  }

  return $permissions[$account->uid][$cid][$op];
}

/**
 * Implements hook_permission().
 */
function paragraphs_permission() {
  // TODO: add an update handler to add type permission for those who have bundle permissions
  $perms = array(
    'administer paragraphs types' => array(
      'title' => t('Administer Paragraph types'),
      'description' => t('Is able to administer Paragraph types for the Paragraphs module'),
    ),
  );
  return $perms;
}


/**
 * Implements hook_menu().
 */
function paragraphs_menu() {
  $items = array();
  $items['admin/structure/paragraphs'] = array(
    'title' => 'Paragraph types',
    'description' => 'Manage Paragraph types',
    'page callback' => 'paragraphs_admin_type_overview',
    'access arguments' => array('administer paragraphs types'),
    'file' => 'paragraphs.admin.inc',
  );

  $items['admin/structure/paragraphs/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/structure/paragraphs/add'] = array(
    'title' => 'Add Paragraph type',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_admin_type_form'),
    'access arguments' => array('administer paragraphs types'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'paragraphs.admin.inc',
  );

  $items['admin/structure/paragraphs/%paragraphs_type'] = array(
    'title' => 'Edit Paragraph type',
    'title callback' => 'paragraphs_type_title_callback',
    'title arguments' => array(3),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_admin_type_form', 3),
    'access arguments' => array('administer paragraphs types'),
    'file' => 'paragraphs.admin.inc',
  );

  $items['admin/structure/paragraphs/%paragraphs_type/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/structure/paragraphs/%paragraphs_type/delete'] = array(
    'title' => 'Delete Paragraph type',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_admin_type_delete_form', 3),
    'access arguments' => array('administer paragraphs types'),
    'file' => 'paragraphs.admin.inc',
  );

  $items['paragraphs/edit/ajax'] = array(
    'title' => 'Edit item callback',
    'page callback' => 'paragraphs_edit_js',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file' => 'paragraphs.ajax.inc',
  );

  $items['paragraphs/collapse/ajax'] = array(
    'title' => 'Close item callback',
    'page callback' => 'paragraphs_collapse_js',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file' => 'paragraphs.ajax.inc',
  );

  $items['paragraphs/remove/ajax'] = array(
    'title' => 'Remove item callback',
    'page callback' => 'paragraphs_remove_js',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file' => 'paragraphs.ajax.inc',
  );

  $items['paragraphs/deleteconfirm/ajax'] = array(
    'title' => 'Remove item callback',
    'page callback' => 'paragraphs_deleteconfirm_js',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file' => 'paragraphs.ajax.inc',
  );

  $items['paragraphs/restore/ajax'] = array(
    'title' => 'Restore item callback',
    'page callback' => 'paragraphs_restore_js',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file' => 'paragraphs.ajax.inc',
  );

  return $items;
}


/**
 * Implements hook_field_info().
 */
function paragraphs_field_info() {
  $info = array();
  $info['paragraphs'] = array(
    'label' => t('Paragraphs'),
    'description' => t('Paragraphs field using the Paragraph types.'),
    'instance_settings' => array(
      'title' => PARAGRAPHS_DEFAULT_TITLE,
      'title_multiple' => PARAGRAPHS_DEFAULT_TITLE_MULTIPLE,
      'allowed_types' => array(),
      'type_weights' => array(),
    ),
    'default_widget' => 'paragraphs_hidden',
    'default_formatter' => 'paragraphs_view',
    'settings' => array(),
  );
  return $info;
}

/**
 * Implements hook_form_field_ui_field_edit_form_alter().
 */
function paragraphs_form_field_ui_field_edit_form_alter(&$form, $form_state) {
  if ($form['#field']['type'] == 'paragraphs') {
    $form['#theme'] = array('paragraphs_type_settings_form');
    array_unshift($form['#submit'], 'paragraphs_type_settings_form_submit');
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function paragraphs_type_settings_form_submit($form, &$form_state) {
  $type_settings = array();
  $type_weights = array();
  if (isset($form_state['values']['instance']['settings']['allowed_types_table'])) {
    $type_settings_table = $form_state['values']['instance']['settings']['allowed_types_table'];
    backdrop_sort($type_settings_table, array('#weight'));
    foreach ($type_settings_table as $machine_name => $value) {
      $type_settings[$machine_name] = (($value['enabled'] === 1) ? $machine_name : -1);
      $type_weights[$machine_name] = $value['weight'];
    }
  }

  $form_state['values']['instance']['settings']['allowed_types'] = $type_settings;
  $form_state['values']['instance']['settings']['type_weights'] = $type_weights;

  unset($form_state['values']['instance']['settings']['allowed_types_table']);
}

/**
 * Implements hook_field_instance_settings_form().
 */
function paragraphs_field_instance_settings_form($field, $instance) {

  $settings = $instance['settings'];
  $types = array();
  $_types = paragraphs_type_load();
  $form_delta = count($_types) * 2;
  $max_weight = 0;
  $weights = array();

  foreach ($_types as $machine_name => $type) {
    $types[$machine_name] = $type->name;
    if (isset($settings['type_weights'][$machine_name])) {
      $weights[$machine_name] = $settings['type_weights'][$machine_name];
      if ($settings['type_weights'][$machine_name] > $max_weight) {
        $max_weight = $settings['type_weights'][$machine_name];
      }
    }
  }

  $max_weight++;

  $element['allowed_types_table'] = array(
    '#tree' => TRUE,
    '#prefix' => '<label>' . t('Allowed Paragraph types') . '</label>',
    '#suffix' => '<div class="description">' . t('If no Paragraph type is selected, all the types will be available.') . '</div>',
  );

  $weight = 1;
  foreach ($_types as $machine_name => $type) {

    $enabled = FALSE;
    if (isset($settings['allowed_types'][$machine_name]) && $settings['allowed_types'][$machine_name] === $machine_name) {
      $enabled = TRUE;
    }

    $element['allowed_types_table'][$machine_name] = array(
      'enabled' => array(
        '#type' => 'checkbox',
        '#title' => check_plain($type->name),
        '#title_display' => 'after',
        '#default_value' => $enabled,
      ),
      'weight' => array(
        '#type' => 'weight',
        '#title' => t('Weight'),
        '#default_value' => (isset($weights[$machine_name]) ? $weights[$machine_name] : $weight + $max_weight),
        '#delta' => $form_delta,
        '#title_display' => 'invisible',
      ),
    );
    $element['allowed_types_table'][$machine_name]['#weight'] = $element['allowed_types_table'][$machine_name]['weight']['#default_value'];
    $weight++;
  }

  $element['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Item Title'),
    '#description' => t('Label to appear as title on the button as "Add new [title]", this label is translatable'),
    '#default_value' => isset($settings['title']) ? $settings['title'] : PARAGRAPHS_DEFAULT_TITLE,
    '#required' => TRUE,
  );

  $element['title_multiple'] = array(
    '#type' => 'textfield',
    '#title' => t('Plural Item Title'),
    '#description' => t('Title in its plural form.'),
    '#default_value' => isset($settings['title_multiple']) ? $settings['title_multiple'] : PARAGRAPHS_DEFAULT_TITLE_MULTIPLE,
    '#required' => TRUE,
  );

  $element['default_edit_mode'] = array(
    '#type' => 'select',
    '#title' => t('Default edit mode'),
    '#description' => t('The default edit mode the paragraph item is in. Preview will render the paragraph in the preview view mode.'),
    '#options' => array(
      'open' => t('Open'),
      'closed' => t('Closed'),
      'preview' => t('Preview'),
    ),
    '#default_value' => isset($settings['default_edit_mode']) ? $settings['default_edit_mode'] : PARAGRAPHS_DEFAULT_EDIT_MODE,
    '#required' => TRUE,
  );

  $element['default_edit_mode_override'] = array(
    '#type' => 'number',
    '#title' => t('Edit mode override'),
    '#title_display' => 'invisible',
    '#field_prefix' => t('Force items to display as "Open" when there are less then '),
    '#field_suffix' => t(' items.'),
    '#default_value' => (isset($settings['default_edit_mode_override']) && !empty($settings['default_edit_mode_override'])) ? $settings['default_edit_mode_override'] : PARAGRAPHS_DEFAULT_EDIT_MODE_OVERRIDE,
    '#states' => array(
      // Hide the settings when the the default edit mode is set to "Open."
      'invisible' => array(
        ':input[name="instance[settings][default_edit_mode]"]' => array('value' => 'open'),
      ),
    ),
    '#size' => 2,
    '#maxlength' => 2,
    // Specify width, since size property isn't supported on number fields.
    '#attributes' => array('style' => 'width:3em'),
    '#min' => 1,
    '#max' => 99,
  );

  $element['add_mode'] = array(
    '#type' => 'select',
    '#title' => t('Add mode'),
    '#description' => t('The way to add new paragraphs.'),
    '#options' => array(
      'select' => t('Select List'),
      'button' => t('Buttons'),
    ),
    '#default_value' => isset($settings['add_mode']) ? $settings['add_mode'] : PARAGRAPHS_DEFAULT_ADD_MODE,
    '#required' => TRUE,
  );

  if (!count($types)) {
    $element['allowed_types_explain'] = array(
      '#type' => 'markup',
      '#markup' => t('You did not add any Paragraph types yet, click !here to add one.', array('!here' => l(t('here'), 'admin/structure/paragraphs/add', array('query' => backdrop_get_destination())))),
    );
  }

  $element['fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Default value'),
    '#collapsible' => FALSE,
    // As field_ui_default_value_widget() does, we change the #parents so that
    // the value below is writing to $instance in the right location.
    '#parents' => array('instance'),
  );
  // Be sure to set the default value to NULL, for example to repair old fields
  // that still have one.
  $element['fieldset']['default_value'] = array(
    '#type' => 'value',
    '#value' => NULL,
  );
  $element['fieldset']['content'] = array(
    '#pre' => '<p>',
    '#markup' => t('To specify a default value, configure it via the regular default value setting of each field that is part of the Paragraph type. To do so, go to the <a href="!url">Manage fields</a> screen of the Paragraph type.', array('!url' => url('admin/structure/paragraphs'))),
    '#suffix' => '</p>',
  );
  return $element;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_paragraphs_type_settings_form($variables) {
  $form = $variables['form'];

  // Initialize the variable which will store our table rows.
  $rows = array();

  uasort($form['instance']['settings']['allowed_types_table'], 'element_sort');

  // Iterate over each element in our $form['example_items'] array.
  foreach (element_children($form['instance']['settings']['allowed_types_table']) as $id) {

    // Before we add our 'weight' column to the row, we need to give the
    // element a custom class so that it can be identified in the
    // backdrop_add_tabledrag call.
    //
    // This could also have been done during the form declaration by adding
    // '#attributes' => array('class' => 'example-item-weight'),
    // directy to the 'weight' element in tabledrag_example_simple_form().
    $form['instance']['settings']['allowed_types_table'][$id]['weight']['#attributes']['class'] = array('paragraphs-type-item-weight');

    // We are now ready to add each element of our $form data to the $rows
    // array, so that they end up as individual table cells when rendered
    // in the final table.  We run each element through the backdrop_render()
    // function to generate the final html markup for that element.
    $rows[] = array(
      'data' => array(
        // Add our 'enabled' column.
        backdrop_render($form['instance']['settings']['allowed_types_table'][$id]['enabled']),
        // Add our 'weight' column.
        backdrop_render($form['instance']['settings']['allowed_types_table'][$id]['weight']),
      ),
      // To support the tabledrag behaviour, we need to assign each row of the
      // table a class attribute of 'draggable'. This will add the 'draggable'
      // class to the <tr> element for that row when the final table is
      // rendered.
      'class' => array('draggable'),
    );
  }

  // We now define the table header values.  Ensure that the 'header' count
  // matches the final column count for your table.
  $header = array(t('Paragraph type'), t('Weight'));

  // We also need to pass the backdrop_add_tabledrag() function an id which will
  // be used to identify the <table> element containing our tabledrag form.
  // Because an element's 'id' should be unique on a page, make sure the value
  // you select is NOT the same as the form ID used in your form declaration.
  $table_id = backdrop_html_id('paragraphs-type-table');

  // We can render our tabledrag table for output.
  $output = theme('table', array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array('id' => $table_id),
  ));

  $form['instance']['settings']['allowed_types_table']['#markup'] = $output;

  // And then render any remaining form elements (such as our submit button).
  $output = backdrop_render_children($form);

  // We now call the backdrop_add_tabledrag() function in order to add the
  // tabledrag.js goodness onto our page.
  //
  // For a basic sortable table, we need to pass it:
  // - the $table_id of our <table> element,
  // - the $action to be performed on our form items ('order'),
  // - a string describing where $action should be applied ('siblings'),
  // - and the class of the element containing our 'weight' element.
  backdrop_add_tabledrag($table_id, 'order', 'sibling', 'paragraphs-type-item-weight');

  return $output;
}

/**
 * Implements hook_field_settings_form().
 */
function paragraphs_field_settings_form($field, $instance) {

  $form = array();
  return $form;
}


/**
 * Implements hook_field_presave().
 *
 * Support saving paragraph items in @code $item['entity'] @endcode. This
 * may be used to seamlessly create paragraph items during host-entity
 * creation or to save changes to the host entity and its collections at once.
 */
function paragraphs_field_presave($host_entity_type, $host_entity, $field, $instance, $langcode, &$items) {
  foreach ($items as $key => &$item) {
    // In case the entity has been changed / created, save it and set the id.
    // If the host entity creates a new revision, save new item-revisions as
    // well.
    $entity = FALSE;
    if (isset($item['entity'])) {
      $entity = paragraphs_field_get_entity($item);
    }
    elseif (isset($item['revision_id'])) {
      $entity = paragraphs_item_revision_load($item['revision_id']);
    }

    if ($entity) {
      $entity->setHostEntity($host_entity_type, $host_entity, $langcode, FALSE);

      // If the host entity supports revisions and is saved as new revision, do the same for the item.
      if (!empty($host_entity->revision)) {
        $entity->revision = TRUE;
        $is_default = paragraphs_entity_revision_is_default($host_entity_type, $host_entity);
        // If an entity type does not support saving non-default entities,
        // assume it will be saved as default.
        if (!isset($is_default) || $is_default) {
          $entity->default_revision = TRUE;
          $entity->archived = FALSE;
        }
      }

      if (isset($entity->removed) && $entity->removed) {
        unset($items[$key]);
      }
      else {
        $entity->save(TRUE);

        $item = array(
          'value' => $entity->item_id,
          'revision_id' => $entity->revision_id,
        );
      }
    }
  }
}


/**
 * Implements hook_field_update().
 *
 * Care about removed paragraph items.
 */
function paragraphs_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  // Prevent workbench moderation from deleting paragraphs on node_save() during
  // workbench_moderation_store(), when $host_entity->revision == 0.
  if (!empty($entity->workbench_moderation['updating_live_revision'])) {
    return;
  }
  // Prevent State Flow Entity from deleting paragraphs on node_save()
  // when adding new paragraphs item and a published revision of the node exist.
  // @see state_flow_entity_exit().
  if (!empty($entity->state_flow) && isset($entity->revision) && $entity->revision === FALSE) {
    return;
  }

  $items_original = !empty($entity->original->{$field['field_name']}[$langcode]) ? $entity->original->{$field['field_name']}[$langcode] : array();
  $original_by_id = array_flip(paragraphs_field_item_to_ids($items_original));

  foreach ($items as $item) {
    unset($original_by_id[$item['value']]);
  }

  // If there are removed items, care about deleting the item entities.
  if ($original_by_id) {
    $ids = array_flip($original_by_id);

    // If we are creating a new revision, the old-items should be kept but get
    // marked as archived now.
    if (!empty($entity->revision)) {
      db_update('paragraphs_item')
        ->fields(array('archived' => 1))
        ->condition('item_id', $ids, 'IN')
        ->execute();
    }
    else {
      // Delete unused paragraph items now.
      foreach (paragraphs_item_load_multiple($ids) as $item) {
        $item->setHostEntity($entity_type, $entity, $langcode, FALSE);
        $item->deleteRevision(TRUE);
      }
    }
  }
}

/**
 * Implements hook_field_delete().
 */
function paragraphs_field_delete($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'paragraphs') {
    // Also delete all embedded entities.
    if ($ids = paragraphs_field_item_to_ids($items)) {
      // We filter out entities that are still being referenced by other
      // host-entities. This should never be the case, but it might happened e.g.
      // when modules cloned a node without knowing about paragraphs.
      $entity_info = entity_get_info($entity_type);
      $entity_id_name = $entity_info['entity keys']['id'];
      $field_column = key($field['columns']);

      // Extra check to make sure our field exists.
      if (is_scalar($field)) {
        $field_definition = field_info_field($field['field_name']);
        if (!empty($field_definition)) {
          foreach ($ids as $id_key => $id) {
            $query = new EntityFieldQuery();
            $entities = $query
              ->fieldCondition($field['field_name'], $field_column, $id)
              ->execute();
            unset($entities[$entity_type][$entity->$entity_id_name]);

            if (!empty($entities[$entity_type])) {
              // Filter this $id out.
              unset($ids[$id_key]);
            }
          }
        }
      }

      entity_delete_multiple('paragraphs_item', $ids);
    }
  }
}

/**
 * Implements hook_field_delete_revision().
 */
function paragraphs_field_delete_revision($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'paragraphs') {
    foreach ($items as $item) {
      if (!empty($item['revision_id'])) {
        if ($paragraphs_item = paragraphs_item_revision_load($item['revision_id'])) {
          $paragraphs_item->setHostEntity($entity_type, $entity, $langcode, FALSE);
          $paragraphs_item->deleteRevision(TRUE);
        }
      }
    }
  }
}

/**
 * Get an array of paragraph item IDs stored in the given field items.
 */
function paragraphs_field_item_to_ids($items) {
  $ids = array();
  foreach ($items as $item) {
    if (!empty($item['value'])) {
      $ids[] = $item['value'];
    }
  }
  return $ids;
}

/**
 * Implements hook_field_is_empty().
 */
function paragraphs_field_is_empty($item, $field) {
  // Item is empty when we removed it.
  if (isset($item['entity']) && ((isset($item['entity']->removed) && $item['entity']->removed) || (isset($item['entity']->confirmed_removed) && $item['entity']->confirmed_removed))) {
    return TRUE;
  }
  if (!empty($item['value'])) {
    return FALSE;
  }
  elseif (isset($item['entity'])) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Determines whether a field paragraphs item entity is empty based on the paragraphs-field.
 */
function paragraphs_item_is_empty(ParagraphsItemEntity $item) {
  // TODO: adjust 'bundle' to 'type' after schema is updated
  $instances = field_info_instances('paragraphs_item', $item->bundle);
  $is_empty = TRUE;

  foreach ($instances as $instance) {
    $field_name = $instance['field_name'];
    $field = field_info_field($field_name);

    // Determine the list of languages to iterate on.
    $languages = field_available_languages('paragraphs_item', $field);

    foreach ($languages as $langcode) {
      if (!empty($item->{$field_name}[$langcode])) {
        // If at least one paragraph is not empty; the
        // paragraph item is not empty.
        foreach ($item->{$field_name}[$langcode] as $field_item) {
          if (!module_invoke($field['module'], 'field_is_empty', $field_item, $field)) {
            $is_empty = FALSE;
          }
        }
      }
    }
  }

  // Allow other modules a chance to alter the value before returning.
  backdrop_alter('paragraphs_is_empty', $is_empty, $item);
  return $is_empty;
}

/**
 * Load a specific type or a list of types
 *
 * @param string|null $name
 *   The machine name or list of types to load when null.
 *
 * @param bool $rebuild
 *   Whether to use cache or not.
 *
 * @return array|stdClass|bool
 *   The type, a list of types, or FALSE when not found.
 */
function paragraphs_type_load($name = NULL, $rebuild = FALSE) {
  $cid = 'paragraphs_types';
  $types = array();

  // Load types from static or from Backdrop cache
  $_types = &backdrop_static($cid);
  if (isset($_types) && !$rebuild) {
    $types = $_types;
  }
  else {
    $_types = cache_get($cid);
    if ($_types && !$rebuild) {
      $types = $_types->data;
    }
    else {
      //TODO: adjust 'bundle' to 'type' after schema is updated
      $query = db_select('paragraphs_bundle', 'pb')
        ->fields('pb')
        ->orderBy('pb.bundle', 'ASC');
      foreach ($query->execute() as $type_object) {
        //TODO: adjust 'bundle' to 'type' after schema is updated
        $types[$type_object->bundle] = $type_object;
      }
      cache_set($cid, $types);
    }
    $_types = $types;
  }

  if ($name) {
    $name = strtr($name, array('-' => '_'));
    if (isset($types[$name])) {
      return $types[$name];
    }
    return FALSE;
  }
  else {
    return $types;
  }
}

/**
 * Menu load callback to scrub a paragraphs type from the URL safe equivalent.
 */
function paragraphs_panelizer_type_name_load($name) {
  if (($type = paragraphs_type_load($name))) {
    return $type->bundle;
  }
}

/**
 * Function to create or update an paragraphs type.
 *
 * @param stdClass $type
 *   The object of the type to create/update.
 *
 * @return int
 *   SAVED_UPDATED when updated, SAVED_NEW when created.
 *
 * @throws Exception
 */
function paragraphs_type_save($type) {
  // TODO: adjust 'bundle' to 'type' after schema is updated
  $is_existing = (bool) db_query_range('SELECT 1 FROM {paragraphs_bundle} WHERE bundle = :type', 0, 1, array(':type' => $type->bundle))->fetchField();

  // TODO: adjust 'bundle' to 'type' after schema is updated
  $fields = array(
    'bundle' => (string) $type->bundle,
    'name' => (string) $type->name,
    'icon' => (isset($type->icon)) ? $type->icon : '',
    'description' => (isset($type->description)) ? (string) $type->description : '',
    'locked' => (int) $type->locked,
  );

  if ($is_existing) {
    // TODO: adjust 'bundle' to 'type' after schema is updated
    db_update('paragraphs_bundle')
      ->fields($fields)
      ->condition('bundle', $type->bundle)
      ->execute();
    $status = SAVED_UPDATED;
  }
  else {
    // TODO: adjust 'bundle' to 'type' after schema is updated
    db_insert('paragraphs_bundle')
      ->fields($fields)
      ->execute();

    $status = SAVED_NEW;
  }

  paragraphs_type_load(NULL, TRUE);
  entity_info_cache_clear();
  state_set('menu_rebuild_needed', TRUE);
  return $status;
}

/**
 * Function to delete a type.
 *
 * @param $type_machine_name
 *   Machine name of the type to delete.
 */
function paragraphs_type_delete($type_machine_name) {
  $type = paragraphs_type_load($type_machine_name);
  if ($type) {
    // TODO: adjust 'bundle' to 'type' after schema is updated
    db_delete('paragraphs_bundle')
      ->condition('bundle', $type->bundle)
      ->execute();
    field_attach_delete_bundle('paragraphs_item', $type->bundle);
    paragraphs_type_load(NULL, TRUE);
    entity_info_cache_clear();
    state_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Helper to get the title of a type.
 *
 * @param $type
 *   The type.
 */
function paragraphs_type_title_callback($type) {
  return t('Edit Paragraph type !name', array('!name' => $type->name));
}

/**
 * Gets a paragraphs item entity for a given field item.
 *
 * @param $field_name
 *   (optional) If given and there is no entity yet, a new entity object is
 *   created for the given item.
 *
 * @return
 *   The entity object or FALSE.
 */
function paragraphs_field_get_entity(&$item, $type = NULL, $field_name = NULL) {
  if (isset($item['entity'])) {
    return $item['entity'];
  }
  elseif (isset($item['value'])) {
    // By default always load the default revision, so caches get used.
    $entity = paragraphs_item_load($item['value']);
    if ($entity && $entity->revision_id != $item['revision_id']) {
      // A non-default revision is a referenced, so load this one.
      $entity = paragraphs_item_revision_load($item['revision_id']);
    }
    return $entity;
  }
  elseif (!isset($item['entity']) && isset($type) && isset($field_name)) {
    $item['entity'] = entity_create('paragraphs_item', array('type' => $type, 'field_name' => $field_name));
    return $item['entity'];
  }
  return FALSE;
}

/**
 * Returns HTML for an individual form element.
 *
 * Combine multiple values into a table with drag-n-drop reordering.
 * TODO : convert to a template.
 *
 * @param $variables
 *   An associative array containing:
 *   - element: A render element representing the form element.
 *
 * @ingroup themeable
 */
function theme_paragraphs_field_multiple_value_form($variables) {
  $element = $variables['element'];
  $output = '';
  $instance = $element['#instance'];

  if (!isset($instance['settings']['title'])) {
    $instance['settings']['title'] = PARAGRAPHS_DEFAULT_TITLE;
  }
  if (!isset($instance['settings']['title_multiple'])) {
    $instance['settings']['title_multiple'] = PARAGRAPHS_DEFAULT_TITLE_MULTIPLE;
  }

  $add_mode = (isset($instance['settings']['add_mode']) ? $instance['settings']['add_mode'] : PARAGRAPHS_DEFAULT_ADD_MODE);

  $required = !empty($element['#required']) ? theme('form_required_marker', $variables) : '';

  // Sort items according to '_weight' (needed when the form comes back after
  // preview or failed validation)
  $items = array();
  foreach (element_children($element) as $key) {
    if ($key === 'add_more') {
      $add_more_button = &$element[$key];
    }
    elseif ($key === 'add_more_type') {
      $add_more_button_type = &$element[$key];
    }
    else {
      if (!isset($element[$key]['#access']) || $element[$key]['#access']) {
        $items[] = &$element[$key];
      }
    }
  }
  usort($items, '_field_sort_items_value_helper');

  // If the field can hold more than one item, display it as a draggable table.
  if ($element['#cardinality'] != 1) {
    $table_id = backdrop_html_id($element['#field_name'] . '_values');
    $order_class = $element['#field_name'] . '-' . $table_id . '-delta-order';

    $header = array(
      array(
        'data' => '<label>' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . '</label>',
        'colspan' => 2,
        'class' => array('field-label'),
      ),
      t('Order'),
    );
    $rows = array();

    // Add the items as table rows.
    foreach ($items as $key => $item) {
      $item['_weight']['#attributes']['class'] = array($order_class);
      $delta_element = backdrop_render($item['_weight']);
      $cells = array(
        array(
          'data' => '',
          'class' => array('field-multiple-drag'),
        ),
        backdrop_render($item),
        array(
          'data' => $delta_element,
          'class' => array('delta-order'),
        ),
      );
      $rows[] = array(
        'data' => $cells,
        'class' => array('draggable', backdrop_html_class('paragraphs_item_type_' . $item['#type'])),
      );
    }

    $field_content = theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => $table_id, 'class' => array('field-multiple-table'))));

    backdrop_add_tabledrag($table_id, 'order', 'sibling', $order_class);
  }
  // If the field can only hold one item, display it without the table wrapper.
  else {
    $value_id = backdrop_html_id($element['#field_name'] . '_value');
    $field_content = '<label for="' . $value_id . '">' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . '</label>';
    if (count($items)) {
      // We don't need to render a weight field when there can only be one item.
      unset($items[0]['_weight']);
      $field_content .= '<div id="' . $value_id . '">' . backdrop_render($items[0]) . '</div>';
    }
  }


  $output = '<div class="form-item">';
  if (count($items)) {
    $output .= $field_content;
  }
  else {
    $add_text = 'No @title_multiple added yet. Select a @title type and press the button below to add one.';
    if ($add_mode == 'button') {
      $add_text = 'No @title_multiple added yet. Select a @title type and press a button below to add one.';
    }
    $output .= '<label>' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . "</label>";
    $output .= '<p><em>' . t($add_text, array('@title_multiple' => t($instance['settings']['title_multiple']), '@title' => t($instance['settings']['title']))) . '</em></p>';
  }
  $output .= $element['#description'] ? '<div class="description">' . $element['#description'] . '</div>' : '';
  $output .= '<div class="clearfix">' . backdrop_render($add_more_button_type) . backdrop_render($add_more_button) . '</div>';
  $output .= '</div>';

  return $output;
}

/**
 * Implements hook_theme().
 */
function paragraphs_theme() {
  return array(
    'paragraphs_field_multiple_value_form' => array(
      'render element' => 'element',
    ),
    'paragraphs_type_settings_form' => array(
      'render element' => 'form',
    ),
    'paragraphs_items' => array(
      'render element' => 'element',
      'template' => 'paragraphs-items',
      'path' => backdrop_get_path('module', 'paragraphs') . '/theme',
      'file' => 'paragraphs.theme.inc',
    ),
    'paragraphs_item' => array(
      'render element' => 'elements',
      'template' => 'paragraphs-item',
      'path' => backdrop_get_path('module', 'paragraphs') . '/theme',
      'file' => 'paragraphs.theme.inc',
    ),
  );
}

/**
 * Implements hook_field_create_field().
 */
function paragraphs_field_create_field($field) {
  if ($field['type'] == 'paragraphs') {

    // Clear caches.
    entity_info_cache_clear();
    // Do not directly issue menu rebuilds here to avoid potentially multiple
    // rebuilds. Instead, let menu_get_item() issue the rebuild on the next
    // request.
    state_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_field_delete_field().
 */
function paragraphs_field_delete_field($field) {
  if ($field['type'] == 'paragraphs') {

    // Clear caches.
    entity_info_cache_clear();
    // Do not directly issue menu rebuilds here to avoid potentially multiple
    // rebuilds. Instead, let menu_get_item() issue the rebuild on the next
    // request.
    state_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_views_api().
 */
function paragraphs_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => backdrop_get_path('module', 'paragraphs') . '/views',
  );
}

/**
 * Implements hook_module_implements_alter().
 */
function paragraphs_module_implements_alter(&$implementations, $hook) {
  switch ($hook) {
    case 'field_attach_form':
      // We put the implementation of field_attach_form implementation of
      // paragraphs at the end, so it has a chance to disable the implementation
      // of entity_translation that provides the form changes that will break
      // paragraphs.
      $group = $implementations['paragraphs'];
      unset($implementations['paragraphs']);
      $implementations['paragraphs'] = $group;
      break;
  }
}

/**
 * Implements hook_field_attach_form().
 */
function paragraphs_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {

  // We make sure paragraphs don't use the entity translation defaults, as those
  // are not implemented properly yet in paragraphs. So we better show an empty
  // initial field for a translation of an existing entity, than making
  // paragraphs break completely.
  // A proper implementation of entity_translation has still to be discussed.
  // @see https://drupal.org/node/2152931
  list( , , $type) = entity_extract_ids($entity_type, $entity);

  foreach (field_info_instances($entity_type, $type) as $instance) {

    $field_name = $instance['field_name'];
    $field_info = field_info_field($field_name);

    if ($field_info['type'] == 'paragraphs') {
      if (isset($form[$field_name])) {
        $element = &$form[$field_name];

        // Remove the entity_translation preparion for the element. This way we
        // avoid that there will be form elements that do not have a
        // corresponding form state for the field.
        if (!empty($element['#process'])) {
          $key = array_search('entity_translation_prepare_element', $element['#process']);

          if ($key !== FALSE) {
            unset($element['#process'][$key]);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_field_prepare_translation().
 *
 * @see field_attach_prepare_translation()
 */
function paragraphs_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, &$items, $source_entity, $source_langcode) {
  if (!module_exists("paragraphs_i18n")) {
    list($id, ,   ) = entity_extract_ids($entity_type, $entity);

    // field_attach_prepare_translation() copied the entity ids from the source,
    // as we need a new entity for a new translation, we cannot reuse that.
    // @todo clone existing paragraphs to new translation
    if (empty($id)) {
      $items = array();
    }
  }
  else {
    paragraphs_i18n_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, $items, $source_entity, $source_langcode);
  }
}

/**
 * Implements hook_features_api().
 */
function paragraphs_features_api() {
  return array(
    'paragraphs' => array(
      'name' => t('Paragraphs types'),
      'feature_source' => TRUE,
      'default_hook' => 'paragraphs_info',
      'file' => backdrop_get_path('module', 'paragraphs') . '/paragraphs.features.inc',
    ),
  );
}

/**
 * Implements hook_type_copy_info to provide a type copy
 * export and import tab.
 */
function paragraphs_type_copy_info() {
  return array(
    'paragraphs_item' => array(
      'type_export_callback' => 'paragraphs_type_load',
      'type_save_callback' => 'paragraphs_type_save',
      'export_menu' => array(
        'path' => 'admin/structure/paragraphs/export',
        'access arguments' => 'administer content types',
      ),
      'import_menu' => array(
        'path' => 'admin/structure/paragraphs/import',
        'access arguments' => 'administer content types',
      ),
    ),
  );
}

/**
 * Helper to ensure entitycache table.
 */
function paragraphs_ensure_entitycache_table() {
  if (module_exists('entitycache') && !db_table_exists('cache_entity_paragraphs_item')) {
    backdrop_load('module', 'entitycache');
    $cache_schema = backdrop_get_schema_unprocessed('system', 'cache');
    $cache_schema['description'] = 'Cache table used to store paragraphs_item entity records.';
    db_create_table('cache_entity_paragraphs_item', $cache_schema);
  }
}

/**
 * Helper to remove entitycache table.
 */
function paragraphs_remove_entitycache_table() {
  if (db_table_exists('cache_entity_paragraphs_item')) {
    db_drop_table('cache_entity_paragraphs_item');
  }
}

/**
 * Implements hook_modules_installed().
 */
function paragraphs_modules_installed($modules) {
  if (in_array('entitycache', $modules)) {
    paragraphs_ensure_entitycache_table();
  }
}

/**
 * Implements hook_modules_uninstalled().
 */
function paragraphs_modules_uninstalled($modules) {
  if (in_array('entitycache', $modules)) {
    paragraphs_remove_entitycache_table();
  }
}

/**
 * Implements hook_autoload_info().
 */
function paragraphs_autoload_info() {
  return array(
    'ParagraphsItemEntity' => 'ParagraphsItemEntity.inc',
    'ParagraphsItemController' => 'ParagraphsItemController.inc',
    'MigrateDestinationParagraphsItem' => 'migrate/destinations/MigrateDestinationParagraphsItem.inc',
    'ParagraphsMigrateParagraphsFieldHandler' => 'migrate/fields/ParagraphsMigrateParagraphsFieldHandler.inc',
    'PanelizerEntityParagraphsItem' => 'plugins/panelizer/entity/PanelizerEntityParagraphsItem.class.php',
    'paragraphs_handler_relationship' => 'views/paragraphs_handler_relationship.inc',
  );
}

function paragraphs_entity_revision_is_default($entity_type, $entity) {
  $info = entity_get_info($entity_type);
  if (empty($info['entity keys']['revision'])) {
    return TRUE;
  }
  // Newly created entities will always be created in default revision.
  if (!empty($entity->is_new) || empty($entity->{$info['entity keys']['id']})) {
    return TRUE;
  }
  $default = entity_load($entity_type, $entity->{$info['entity keys']['id']});
  return $default->{$info['entity keys']['revision']} == $entity->{$info['entity keys']['revision']};
}

/**
 * Deletes an entity revision.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $revision_id
 *   The revision ID to delete.
 *
 * @return
 *   TRUE if the entity revision could be deleted, FALSE otherwise.
 */
function paragraphs_entity_revision_delete($entity_type, $revision_id) {
  $info = entity_get_info($entity_type);
  if (isset($info['revision deletion callback'])) {
    return $info['revision deletion callback']($revision_id, $entity_type);
  }
  else {
    return entity_get_controller($entity_type)->deleteRevision($revision_id);
  }
}


/**
 * This recreates D7 Entity API entity_access and will need to go once that
 * function is in core.
 */
function paragraphs_entity_access($op, $entity_type, $entity = NULL, $account = NULL) {
  if (($info = entity_get_info()) && isset($info[$entity_type]['access callback'])) {
    return $info[$entity_type]['access callback']($op, $entity, $account, $entity_type);
  }
  else {
    switch ($entity_type) {
      case 'node':
        if (isset($entity)) {
          return node_access($op, $entity, $account);
        }
        // Is access to all nodes allowed?
        if (!user_access('access content', $account)) {
          return FALSE;
        }
        if (user_access('bypass node access', $account) || (!isset($account) && $op == 'view' && node_access_view_all_nodes())) {
          return TRUE;
        }
        return FALSE;
        break;
      case 'user':
        $account = isset($account) ? $account : $GLOBALS['user'];
        // Grant access to the users own user account and to the anonymous one.
        if (isset($entity) && $op != 'delete' && (($entity->uid == $account->uid && $entity->uid) || (!$entity->uid && $op == 'view'))) {
          return TRUE;
        }
        if (user_access('administer users', $account) || user_access('access user profiles', $account) && $op == 'view' && $entity->status) {
          return TRUE;
        }
        return FALSE;
        break;
      case 'comment':
        // When determining access to a comment, 'comment_access' does not take any
        // access restrictions to the comment's associated node into account. If a
        // comment has an associated node, the user must be able to view it in order
        // to access the comment.
        if (isset($entity->nid)) {
          if (!entity_access('view', 'node', node_load($entity->nid), $account)) {
            return FALSE;
          }
        }
        if (isset($entity) && $op == 'update') {
          // Because 'comment_access' only checks the current user, we need to do our
          // own access checking if an account was specified.
          if (!isset($account)) {
            return comment_access('edit', $entity);
          }
          else {
            return ($account->uid && $account->uid == $entity->uid && $entity->status == COMMENT_PUBLISHED && user_access('edit own comments', $account)) || user_access('administer comments', $account);
          }
        }
        if (user_access('administer comments', $account) || user_access('access comments', $account) && $op == 'view') {
          return TRUE;
        }
        return FALSE;
        break;
      case 'taxonomy_term':
      case 'taxonomy_vocabulary':
        if ($entity_type == 'taxonomy_vocabulary') {
          return user_access('administer taxonomy', $account);
        }
        $taxonomy_term_edit_access = user_access("edit terms in $entity->vocabulary") || user_access('administer taxonomy');
        if (isset($entity) && $op == 'edit' && !isset($account) && $taxonomy_term_edit_access) {
          return TRUE;
        }
        if (user_access('administer taxonomy', $account) || user_access('access content', $account) && $op == 'view') {
          return TRUE;
        }
        return FALSE;
        break;
    }
  }
}

/**
  * Deprecated functions from Paragraphs 1.0.
  * ("Bundle" is replaced by "Type").
  */
  
function paragraphs_bundle_load ($name = NULL, $rebuild = FALSE) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_type_load($name, $rebuild);
}

function paragraphs_bundle_save($type) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_type_save($type);
}

function paragraphs_panelizer_bundle_name_load($name) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_panelizer_type_name_load($name);
}

function paragraphs_bundle_settings_form_submit($form, &$form_state) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_type_settings_form_submit($form, $form_state);
}

function theme_paragraphs_bundle_settings_form($variables) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return theme_paragraphs_type_settings_form($variables);
}

function paragraphs_bundle_delete($type_machine_name) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_type_delete($type_machine_name);
}

function paragraphs_bundle_title_callback($type) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_type_title_callback($type);
}

function paragraphs_bundle_copy_info() {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_type_copy_info();
}

function paragraphs_admin_bundle_overview() {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_admin_type_overview();
}

function paragraphs_admin_bundle_form($form, &$form_state, $type = NULL) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_admin_type_form($form, $form_state, $type = NULL);
}

function paragraphs_admin_bundle_form_validate($form, &$form_state) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_admin_type_form_validate($form, $form_state);
}

function paragraphs_admin_bundle_form_submit($form, &$form_state) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_admin_type_form_submit($form, $form_state);
}

function paragraphs_admin_bundle_delete_form($form, &$form_state, $type) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_admin_type_delete_form($form, $form_state, $type);
}

function paragraphs_admin_bundle_delete_form_submit($form, &$form_state) {
  watchdog_deprecated_function('paragraphs', __FUNCTION__);
  return paragraphs_admin_type_delete_form_submit($form, $form_state);
}